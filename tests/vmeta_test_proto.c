/**
 * Copyright (c) 2016 Parrot Drones SAS
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *   * Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *   * Neither the name of the Parrot Drones SAS Company nor the
 *     names of its contributors may be used to endorse or promote products
 *     derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE PARROT DRONES SAS COMPANY BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "vmeta_test.h"


/**
 * This array can be generated by using the test executable with the 'dump'
 * argument. E.g.:
 * $ ./out/pdraw-linux/staging/native-wrapper.sh tst-vmeta dump
 * The generated data can be verified by dumping the binary data to a file and
 * using:
 * $ protoc --proto_path packages/libvideo-metadata/proto/ \
 *   packages/libvideo-metadata/proto/vmeta.proto --decode=vmeta.TimedMetadata \
 *   < dump.bin
 */
static const uint8_t packed_meta[] = {
	0x0a, 0x83, 0x01, 0x0a, 0x14, 0x0d, 0xba, 0xf4, 0x3a, 0x3e, 0x15, 0xba,
	0xf4, 0xba, 0x3e, 0x1d, 0x8c, 0x37, 0x0c, 0x3f, 0x25, 0xba, 0xf4, 0x3a,
	0x3f, 0x12, 0x27, 0x09, 0x9a, 0x99, 0x99, 0x99, 0x99, 0x99, 0xb9, 0x3f,
	0x11, 0x9a, 0x99, 0x99, 0x99, 0x99, 0x99, 0xc9, 0x3f, 0x19, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x40, 0x7a, 0x40, 0x20, 0x0f, 0x2d, 0x9a, 0x99, 0x99,
	0x3e, 0x35, 0xcd, 0xcc, 0xcc, 0x3e, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x80, 0x50, 0x40, 0x22, 0x0f, 0x0d, 0x00, 0x00, 0x28, 0x42, 0x15, 0x14,
	0xae, 0x29, 0x42, 0x1d, 0x3d, 0x0a, 0xd7, 0x3e, 0x28, 0x54, 0x38, 0x02,
	0x4a, 0x0f, 0x0d, 0x00, 0x00, 0x28, 0x42, 0x15, 0x14, 0xae, 0x29, 0x42,
	0x1d, 0x3d, 0x0a, 0xd7, 0x3e, 0x52, 0x0f, 0x0d, 0x00, 0x00, 0x28, 0x42,
	0x15, 0x14, 0xae, 0x29, 0x42, 0x1d, 0x3d, 0x0a, 0xd7, 0x3e, 0x58, 0x01,
	0x60, 0x02, 0x12, 0x57, 0x08, 0xc2, 0x84, 0x89, 0x92, 0x04, 0x12, 0x14,
	0x0d, 0xba, 0xf4, 0x3a, 0x3e, 0x15, 0xba, 0xf4, 0xba, 0x3e, 0x1d, 0x8c,
	0x37, 0x0c, 0x3f, 0x25, 0xba, 0xf4, 0x3a, 0x3f, 0x1a, 0x14, 0x0d, 0xba,
	0xf4, 0x3a, 0x3e, 0x15, 0xba, 0xf4, 0xba, 0x3e, 0x1d, 0x8c, 0x37, 0x0c,
	0x3f, 0x25, 0xba, 0xf4, 0x3a, 0x3f, 0x25, 0x00, 0x00, 0x28, 0x42, 0x28,
	0xb8, 0x17, 0x35, 0x00, 0x00, 0x80, 0x40, 0x3d, 0x00, 0x00, 0x40, 0x40,
	0x45, 0x00, 0x00, 0x70, 0x42, 0x4d, 0x00, 0x00, 0x96, 0x42, 0x50, 0xa4,
	0xc8, 0x90, 0xa1, 0x02, 0x58, 0x88, 0x27, 0x1a, 0x0a, 0x0a, 0x08, 0x08,
	0x90, 0x4e, 0x10, 0x01, 0x18, 0x9f, 0x01, 0x1a, 0x0e, 0x12, 0x0c, 0x0a,
	0x08, 0x08, 0x02, 0x10, 0x01, 0x18, 0x03, 0x20, 0x01, 0x10, 0x03, 0x22,
	0x2d, 0x0a, 0x1d, 0x0d, 0x29, 0x5c, 0x0f, 0x3e, 0x15, 0x3d, 0x0a, 0x57,
	0x3f, 0x1d, 0x9a, 0x99, 0x99, 0x3e, 0x25, 0x0a, 0xd7, 0x23, 0x3c, 0x28,
	0x05, 0x35, 0x00, 0x00, 0x00, 0x3f, 0x38, 0x2a, 0x10, 0xc1, 0x82, 0x85,
	0x8a, 0x04, 0x18, 0x80, 0x01, 0x28, 0xe7, 0x8a, 0x8d, 0x09, 0x2a, 0x63,
	0x0a, 0x1d, 0x0d, 0x29, 0x5c, 0x0f, 0x3e, 0x15, 0x3d, 0x0a, 0x57, 0x3f,
	0x1d, 0x9a, 0x99, 0x99, 0x3e, 0x25, 0x0a, 0xd7, 0x23, 0x3c, 0x28, 0x05,
	0x35, 0x00, 0x00, 0x00, 0x3f, 0x38, 0x2a, 0x0a, 0x1d, 0x0d, 0x29, 0x5c,
	0x0f, 0x3e, 0x15, 0x3d, 0x0a, 0x57, 0x3f, 0x1d, 0x9a, 0x99, 0x99, 0x3e,
	0x25, 0x0a, 0xd7, 0x23, 0x3c, 0x28, 0x05, 0x35, 0x00, 0x00, 0x00, 0x3f,
	0x38, 0x2a, 0x0a, 0x1d, 0x0d, 0x29, 0x5c, 0x0f, 0x3e, 0x15, 0x3d, 0x0a,
	0x57, 0x3f, 0x1d, 0x9a, 0x99, 0x99, 0x3e, 0x25, 0x0a, 0xd7, 0x23, 0x3c,
	0x28, 0x05, 0x35, 0x00, 0x00, 0x00, 0x3f, 0x38, 0x2a, 0x10, 0xc0, 0x80,
	0x81, 0x82, 0x04, 0x32, 0x58, 0x0a, 0x27, 0x09, 0x9a, 0x99, 0x99, 0x99,
	0x99, 0x99, 0xb9, 0x3f, 0x11, 0x9a, 0x99, 0x99, 0x99, 0x99, 0x99, 0xc9,
	0x3f, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x7a, 0x40, 0x20, 0x0f,
	0x2d, 0x9a, 0x99, 0x99, 0x3e, 0x35, 0xcd, 0xcc, 0xcc, 0x3e, 0x12, 0x27,
	0x09, 0x9a, 0x99, 0x99, 0x99, 0x99, 0x99, 0xb9, 0x3f, 0x11, 0x9a, 0x99,
	0x99, 0x99, 0x99, 0x99, 0xc9, 0x3f, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x40, 0x7a, 0x40, 0x20, 0x0f, 0x2d, 0x9a, 0x99, 0x99, 0x3e, 0x35, 0xcd,
	0xcc, 0xcc, 0x3e, 0x20, 0x01, 0x28, 0x01, 0x30, 0x0a, 0x3a, 0x35, 0x08,
	0x01, 0x12, 0x0f, 0x0d, 0xcd, 0xcc, 0xcc, 0x3d, 0x15, 0xcd, 0xcc, 0x4c,
	0x3e, 0x1d, 0x9a, 0x99, 0x99, 0x3e, 0x1a, 0x0f, 0x0d, 0xcd, 0xcc, 0xcc,
	0x3d, 0x15, 0xcd, 0xcc, 0x4c, 0x3e, 0x1d, 0x9a, 0x99, 0x99, 0x3e, 0x22,
	0x0f, 0x0d, 0xcd, 0xcc, 0xcc, 0x3d, 0x15, 0xcd, 0xcc, 0x4c, 0x3e, 0x1d,
	0x9a, 0x99, 0x99, 0x3e,
};


static bool maybe(bool random)
{
	return random ? futils_randomr8_maximum(1) : 1;
}


static void fill_quaternion(Vmeta__Quaternion *quat, bool random)
{
	if (random) {
		quat->w = futils_randomrf();
		quat->x = futils_randomrf();
		quat->y = futils_randomrf();
		quat->z = futils_randomrf();
	} else {
		quat->w = 0.1f;
		quat->x = 0.2f;
		quat->y = 0.3f;
		quat->z = 0.4f;
	}
	/* Make the quaternion a unit quaternion */
	float norm = sqrtf(powf(quat->w, 2) + powf(quat->x, 2) +
			   powf(quat->y, 2) + powf(quat->z, 2));
	quat->w /= norm;
	quat->x /= norm;
	quat->y /= norm;
	quat->z /= norm;
}


static void fill_location(Vmeta__Location *loc, bool random)
{
	if (random) {
		loc->altitude = futils_randomrd();
		loc->latitude = futils_randomrd();
		loc->longitude = futils_randomrd();
		loc->horizontal_accuracy = futils_randomrd();
		loc->vertical_accuracy = futils_randomrd();
		loc->sv_count = futils_randomr8();
	} else {
		loc->altitude = 420.;
		loc->latitude = 0.1;
		loc->longitude = 0.2;
		loc->horizontal_accuracy = 0.3;
		loc->vertical_accuracy = 0.4;
		loc->sv_count = 15;
	}
}


static void fill_vector3(Vmeta__Vector3 *vec3, bool random)
{
	if (random) {
		vec3->x = futils_randomrf();
		vec3->y = futils_randomrf();
		vec3->z = futils_randomrf();
	} else {
		vec3->x = 42.f;
		vec3->y = 42.42f;
		vec3->z = 0.42f;
	}
}


static void fill_ned(Vmeta__NED *ned, bool random)
{
	if (random) {
		ned->north = futils_randomrf();
		ned->east = futils_randomrf();
		ned->down = futils_randomrf();
	} else {
		ned->north = 42.f;
		ned->east = 42.42f;
		ned->down = 0.42f;
	}
}


static void fill_bounding_box(Vmeta__BoundingBox *box, bool random)
{
	if (random) {
		box->object_class = futils_randomr32_maximum(
			VMETA__TRACKING_CLASS__TC_UNDEFINED);
		box->x = futils_randomrf();
		box->y = futils_randomrf();
		box->width = futils_randomrf();
		box->height = futils_randomrf();
		box->confidence = futils_randomrf();
		box->uid = futils_randomr32();
	} else {
		box->object_class = VMETA__TRACKING_CLASS__TC_HORSE;
		box->x = 0.14f;
		box->y = 0.84f;
		box->width = 0.3f;
		box->height = 0.01f;
		box->confidence = 0.5f;
		box->uid = 42;
	}
}


static void fill_thermal_spot(Vmeta__ThermalSpot *spot, int random)
{
	if (random) {
		spot->x = futils_randomrf();
		spot->y = futils_randomrf();
		spot->temp = futils_randomrf();
	} else {
		spot->x = 0.1f;
		spot->y = 0.2f;
		spot->temp = 0.3f;
	}
}


static struct vmeta_frame *unpacked_meta(int random)
{
	int err;
	struct vmeta_frame *frame;
	err = vmeta_frame_new(VMETA_FRAME_TYPE_PROTO, &frame);
	CU_ASSERT_PTR_NOT_NULL(frame);
	CU_ASSERT_EQUAL(err, 0);
	Vmeta__TimedMetadata *meta;
	err = vmeta_frame_proto_get_unpacked_rw(frame, &meta);
	CU_ASSERT_PTR_NOT_NULL(meta);
	CU_ASSERT_EQUAL(err, 0);

	if (maybe(random)) {
		Vmeta__DroneMetadata *drone = vmeta_frame_proto_get_drone(meta);
		CU_ASSERT_PTR_NOT_NULL(drone);
		if (random) {
			drone->battery_percentage =
				futils_randomr32_maximum(100);
			drone->flying_state = futils_randomr32_maximum(
				VMETA__FLYING_STATE__FS_EMERGENCY_LANDING);
			drone->ground_distance = futils_randomrd();
			drone->animation_in_progress =
				futils_randomr8_maximum(1);
			drone->piloting_mode = futils_randomr32_maximum(
				VMETA__PILOTING_MODE__PM_MAGIC_CARPET);
		} else {
			drone->battery_percentage = 42;
			drone->flying_state = VMETA__FLYING_STATE__FS_HOVERING;
			drone->ground_distance = 0x42;
			drone->animation_in_progress = true;
			drone->piloting_mode =
				VMETA__PILOTING_MODE__PM_RETURN_HOME;
		}

		if (maybe(random)) {
			Vmeta__Quaternion *drone_quat =
				vmeta_frame_proto_get_drone_quat(drone);
			CU_ASSERT_PTR_NOT_NULL(drone_quat);
			fill_quaternion(drone_quat, random);
		}

		if (maybe(random)) {
			Vmeta__Location *drone_loc =
				vmeta_frame_proto_get_drone_location(drone);
			CU_ASSERT_PTR_NOT_NULL(drone_loc);
			fill_location(drone_loc, random);
		}

		if (maybe(random)) {
			Vmeta__NED *drone_position =
				vmeta_frame_proto_get_drone_position(drone);
			CU_ASSERT_PTR_NOT_NULL(drone_position);
			fill_ned(drone_position, random);
		}

		if (maybe(random)) {
			Vmeta__Vector3 *drone_local_position =
				vmeta_frame_proto_get_drone_local_position(
					drone);
			CU_ASSERT_PTR_NOT_NULL(drone_local_position);
			fill_vector3(drone_local_position, random);
		}

		if (maybe(random)) {
			Vmeta__NED *drone_speed =
				vmeta_frame_proto_get_drone_speed(drone);
			CU_ASSERT_PTR_NOT_NULL(drone_speed);
			fill_ned(drone_speed, random);
		}
	}

	if (maybe(random)) {
		Vmeta__CameraMetadata *camera =
			vmeta_frame_proto_get_camera(meta);
		CU_ASSERT_PTR_NOT_NULL(camera);
		if (random) {
			camera->timestamp = futils_randomr64();
			camera->utc_timestamp = futils_randomr64();
			camera->utc_timestamp_accuracy = futils_randomr32();
			camera->awb_b_gain = futils_randomrf();
			camera->awb_r_gain = futils_randomrf();
			camera->exposure_time = futils_randomrf();
			camera->hfov = futils_randomrf();
			camera->vfov = futils_randomrf();
			camera->iso_gain = futils_randomr16();
		} else {
			camera->timestamp = UINT64_C(0x42424242);
			camera->utc_timestamp = UINT64_C(0x24242424);
			camera->utc_timestamp_accuracy = 5000;
			camera->awb_b_gain = 3.f;
			camera->awb_r_gain = 4.f;
			camera->exposure_time = 42.f;
			camera->hfov = 60.f;
			camera->vfov = 75.f;
			camera->iso_gain = 3000;
		}

		if (maybe(random)) {
			Vmeta__Quaternion *camera_base_quat =
				vmeta_frame_proto_get_camera_base_quat(camera);
			CU_ASSERT_PTR_NOT_NULL(camera_base_quat);
			fill_quaternion(camera_base_quat, random);
		}

		if (maybe(random)) {
			Vmeta__Quaternion *camera_quat =
				vmeta_frame_proto_get_camera_quat(camera);
			CU_ASSERT_PTR_NOT_NULL(camera_quat);
			fill_quaternion(camera_quat, random);
		}
	}

	if (random) {
		size_t n_links = futils_randomr32_maximum(10);
		for (size_t i = 0; i < n_links; i++) {
			/* Protocol case 0 not supported */
			Vmeta__LinkMetadata__ProtocolCase protocol =
				futils_randomr32_maximum(
					VMETA__LINK_METADATA__PROTOCOL_STARFISH -
					1) +
				1;
			switch (protocol) {
			case VMETA__LINK_METADATA__PROTOCOL_WIFI: {
				Vmeta__WifiLinkMetadata *wifi =
					vmeta_frame_proto_add_wifi_link(meta);
				CU_ASSERT_PTR_NOT_NULL(wifi);
				wifi->goodput = futils_randomr32();
				wifi->quality = futils_randomr32_maximum(5);
				wifi->rssi = -128 + futils_randomr8();
			} break;
			case VMETA__LINK_METADATA__PROTOCOL_STARFISH: {
				Vmeta__StarfishLinkMetadata *starfish =
					vmeta_frame_proto_add_starfish_link(
						meta);
				CU_ASSERT_PTR_NOT_NULL(starfish);
				size_t n_starfish_sublinks =
					futils_randomr32_maximum(5);
				for (size_t j = 0; j < n_starfish_sublinks;
				     j++) {
					Vmeta__StarfishLinkInfo *info =
						vmeta_frame_proto_add_starfish_link_info(
							starfish);
					CU_ASSERT_PTR_NOT_NULL(info);
					info->active =
						futils_randomr8_maximum(1);
					info->quality =
						futils_randomr32_maximum(5);
					info->status = futils_randomr32_maximum(
						VMETA__LINK_STATUS__LINK_STATUS_ERROR);
					info->type = futils_randomr32_maximum(
						VMETA__LINK_TYPE__LINK_TYPE_CELLULAR);
				}
			} break;
			default:
				CU_FAIL("Bad protocol");
				break;
			}
		}
	} else {
		Vmeta__WifiLinkMetadata *wifi =
			vmeta_frame_proto_add_wifi_link(meta);
		CU_ASSERT_PTR_NOT_NULL(wifi);
		wifi->goodput = 10000;
		wifi->quality = 1;
		wifi->rssi = -80;
		Vmeta__StarfishLinkMetadata *starfish =
			vmeta_frame_proto_add_starfish_link(meta);
		CU_ASSERT_PTR_NOT_NULL(starfish);
		starfish->quality = 3;
		Vmeta__StarfishLinkInfo *info =
			vmeta_frame_proto_add_starfish_link_info(starfish);
		CU_ASSERT_PTR_NOT_NULL(info);
		info->active = true;
		info->quality = 3;
		info->status = VMETA__LINK_STATUS__LINK_STATUS_UP;
		info->type = VMETA__LINK_TYPE__LINK_TYPE_LAN;
	}

	if (maybe(random)) {
		Vmeta__TrackingMetadata *tracking =
			vmeta_frame_proto_get_tracking(meta);
		CU_ASSERT_PTR_NOT_NULL(tracking);
		if (random) {
			tracking->timestamp = futils_randomr64();
			tracking->quality = futils_randomr8();
			tracking->state = futils_randomr32_maximum(
				VMETA__TRACKING_STATE__TS_SEARCHING);
			tracking->cookie = futils_randomr32();
		} else {
			tracking->timestamp = UINT64_C(0x41414141);
			tracking->quality = 128;
			tracking->state = VMETA__TRACKING_STATE__TS_TRACKING;
			tracking->cookie = 0x01234567;
		}

		if (maybe(random)) {
			Vmeta__BoundingBox *box =
				vmeta_frame_proto_get_tracking_target(tracking);
			CU_ASSERT_PTR_NOT_NULL(box);
			fill_bounding_box(box, random);
		}
	}

	if (maybe(random)) {
		Vmeta__TrackingProposalMetadata *proposal =
			vmeta_frame_proto_get_proposal(meta);
		CU_ASSERT_PTR_NOT_NULL(proposal);
		if (random)
			proposal->timestamp = futils_randomr64();
		else
			proposal->timestamp = UINT64_C(0x40404040);
		size_t nprops = random ? futils_randomr32_maximum(20) : 3;
		for (size_t i = 0; i < nprops; i++) {
			Vmeta__BoundingBox *box =
				vmeta_frame_proto_proposal_add_box(proposal);
			CU_ASSERT_PTR_NOT_NULL(box);
			fill_bounding_box(box, random);
		}
	}

	if (maybe(random)) {
		Vmeta__AutomationMetadata *automation =
			vmeta_frame_proto_get_automation(meta);
		CU_ASSERT_PTR_NOT_NULL(automation);
		if (random) {
			automation->angle_locked = futils_randomr8_maximum(1);
			automation->animation = futils_randomr32();
			automation->follow_me = futils_randomr8_maximum(1);
			automation->lookat_me = futils_randomr8_maximum(1);
		} else {
			automation->angle_locked = true;
			automation->animation =
				VMETA__ANIMATION__ANIM_FLIP_FRONT;
			automation->follow_me = false;
			automation->lookat_me = true;
		}

		if (maybe(random)) {
			Vmeta__Location *destination =
				vmeta_frame_proto_get_automation_destination(
					automation);
			CU_ASSERT_PTR_NOT_NULL(destination);
			fill_location(destination, random);
		}

		if (maybe(random)) {
			Vmeta__Location *target =
				vmeta_frame_proto_get_automation_target_location(
					automation);
			CU_ASSERT_PTR_NOT_NULL(target);
			fill_location(target, random);
		}
	}

	if (maybe(random)) {
		Vmeta__ThermalMetadata *thermal =
			vmeta_frame_proto_get_thermal(meta);
		CU_ASSERT_PTR_NOT_NULL(thermal);
		if (random)
			thermal->calibration_state = futils_randomr32_maximum(
				VMETA__THERMAL_CALIBRATION_STATE__TCS_IN_PROGRESS);
		else
			thermal->calibration_state =
				VMETA__THERMAL_CALIBRATION_STATE__TCS_REQUESTED;

		if (maybe(random)) {
			Vmeta__ThermalSpot *min =
				vmeta_frame_proto_get_thermal_min(thermal);
			CU_ASSERT_PTR_NOT_NULL(min);
			fill_thermal_spot(min, random);
		}

		if (maybe(random)) {
			Vmeta__ThermalSpot *max =
				vmeta_frame_proto_get_thermal_max(thermal);
			CU_ASSERT_PTR_NOT_NULL(max);
			fill_thermal_spot(max, random);
		}

		if (maybe(random)) {
			Vmeta__ThermalSpot *probe =
				vmeta_frame_proto_get_thermal_probe(thermal);
			CU_ASSERT_PTR_NOT_NULL(probe);
			fill_thermal_spot(probe, random);
		}
	}

	err = vmeta_frame_proto_release_unpacked_rw(frame, meta);
	CU_ASSERT_EQUAL(err, 0);

	return frame;
}


static void compare_drone(Vmeta__DroneMetadata *d1, Vmeta__DroneMetadata *d2)
{
	VMETA_ASSERT_BOTH_NULL_NOTNULL(d1, d2);
	if (!d1 || !d2)
		return;

	CU_ASSERT_EQUAL(d1->animation_in_progress, d2->animation_in_progress);
	CU_ASSERT_EQUAL(d1->battery_percentage, d2->battery_percentage);
	CU_ASSERT_EQUAL(d1->flying_state, d2->flying_state);
	CU_ASSERT_EQUAL(d1->ground_distance, d2->ground_distance);
	CU_ASSERT_EQUAL(d1->piloting_mode, d2->piloting_mode);
	compare_proto_quaternion(d1->quat, d2->quat);
	compare_proto_ned(d1->position, d2->position);
	compare_proto_ned(d1->speed, d2->speed);
	compare_proto_vector3(d1->local_position, d2->local_position);
	compare_proto_location(d1->location, d2->location);
}


static void compare_camera(Vmeta__CameraMetadata *c1, Vmeta__CameraMetadata *c2)
{
	VMETA_ASSERT_BOTH_NULL_NOTNULL(c1, c2);
	if (!c1 || !c2)
		return;

	CU_ASSERT_EQUAL(c1->awb_b_gain, c2->awb_b_gain);
	CU_ASSERT_EQUAL(c1->awb_r_gain, c2->awb_r_gain);
	CU_ASSERT_EQUAL(c1->exposure_time, c2->exposure_time);
	CU_ASSERT_EQUAL(c1->hfov, c2->hfov);
	CU_ASSERT_EQUAL(c1->iso_gain, c2->iso_gain);
	CU_ASSERT_EQUAL(c1->timestamp, c2->timestamp);
	CU_ASSERT_EQUAL(c1->utc_timestamp, c2->utc_timestamp);
	CU_ASSERT_EQUAL(c1->utc_timestamp_accuracy, c2->utc_timestamp_accuracy);
	CU_ASSERT_EQUAL(c1->vfov, c2->vfov);
	compare_proto_quaternion(c1->base_quat, c2->base_quat);
	compare_proto_quaternion(c1->quat, c2->quat);
}


static void compare_proposal(Vmeta__TrackingProposalMetadata *p1,
			     Vmeta__TrackingProposalMetadata *p2)
{
	VMETA_ASSERT_BOTH_NULL_NOTNULL(p1, p2);
	if (!p1 || !p2)
		return;

	CU_ASSERT_EQUAL(p1->n_proposals, p2->n_proposals);
	if (p1->n_proposals != p2->n_proposals)
		return;
	for (size_t i = 0; i < p1->n_proposals; i++)
		compare_proto_bounding_box(p1->proposals[i], p2->proposals[i]);
}


static void compare_tracking(Vmeta__TrackingMetadata *t1,
			     Vmeta__TrackingMetadata *t2)
{
	VMETA_ASSERT_BOTH_NULL_NOTNULL(t1, t2);
	if (!t1 || !t2)
		return;

	CU_ASSERT_EQUAL(t1->quality, t2->quality);
	CU_ASSERT_EQUAL(t1->state, t2->state);
	compare_proto_bounding_box(t1->target, t2->target);
}


static void compare_wifi(Vmeta__WifiLinkMetadata *w1,
			 Vmeta__WifiLinkMetadata *w2)
{
	VMETA_ASSERT_BOTH_NULL_NOTNULL(w1, w2);
	if (!w1 || !w2)
		return;

	CU_ASSERT_EQUAL(w1->goodput, w2->goodput);
	CU_ASSERT_EQUAL(w1->quality, w2->quality);
	CU_ASSERT_EQUAL(w1->rssi, w2->rssi);
}


static void compare_starfish_link_info(Vmeta__StarfishLinkInfo *s1,
				       Vmeta__StarfishLinkInfo *s2)
{
	VMETA_ASSERT_BOTH_NULL_NOTNULL(s1, s2);
	if (!s1 || !s2)
		return;

	CU_ASSERT_EQUAL(s1->type, s2->type);
	CU_ASSERT_EQUAL(s1->status, s2->status);
	CU_ASSERT_EQUAL(s1->quality, s2->quality);
	CU_ASSERT_EQUAL(s1->active, s2->active);
}


static void compare_starfish(Vmeta__StarfishLinkMetadata *s1,
			     Vmeta__StarfishLinkMetadata *s2)
{
	VMETA_ASSERT_BOTH_NULL_NOTNULL(s1, s2);
	if (!s1 || !s2)
		return;

	CU_ASSERT_EQUAL(s1->n_links, s2->n_links);
	if (s1->n_links == s2->n_links) {
		for (size_t i = 0; i < s2->n_links; i++)
			compare_starfish_link_info(s1->links[i], s2->links[i]);
	}
	CU_ASSERT_EQUAL(s1->quality, s2->quality);
}


static void compare_link(Vmeta__LinkMetadata *l1, Vmeta__LinkMetadata *l2)
{
	VMETA_ASSERT_BOTH_NULL_NOTNULL(l1, l2);
	if (!l1 || !l2)
		return;

	CU_ASSERT_EQUAL(l1->protocol_case, l2->protocol_case);
	if (l1->protocol_case != l2->protocol_case)
		return;

	switch (l1->protocol_case) {
	case VMETA__LINK_METADATA__PROTOCOL_WIFI:
		CU_ASSERT_PTR_NOT_NULL(l1->wifi);
		CU_ASSERT_PTR_NOT_NULL(l2->wifi);
		compare_wifi(l1->wifi, l2->wifi);
		break;
	case VMETA__LINK_METADATA__PROTOCOL_STARFISH:
		CU_ASSERT_PTR_NOT_NULL(l1->starfish);
		CU_ASSERT_PTR_NOT_NULL(l2->starfish);
		compare_starfish(l1->starfish, l2->starfish);
		break;
	default:
		break;
	}
}


static void compare_automation(Vmeta__AutomationMetadata *a1,
			       Vmeta__AutomationMetadata *a2)
{
	VMETA_ASSERT_BOTH_NULL_NOTNULL(a1, a2);
	if (!a1 || !a2)
		return;

	CU_ASSERT_EQUAL(a1->angle_locked, a2->angle_locked);
	CU_ASSERT_EQUAL(a1->animation, a2->animation);
	CU_ASSERT_EQUAL(a1->follow_me, a2->follow_me);
	CU_ASSERT_EQUAL(a1->lookat_me, a2->lookat_me);
	compare_proto_location(a1->destination, a2->destination);
	compare_proto_location(a1->target_location, a2->target_location);
}


static void compare_thermal(Vmeta__ThermalMetadata *t1,
			    Vmeta__ThermalMetadata *t2)
{
	VMETA_ASSERT_BOTH_NULL_NOTNULL(t1, t2);
	if (!t1 || !t2)
		return;

	CU_ASSERT_EQUAL(t1->calibration_state, t2->calibration_state);
	compare_proto_thermal_spot(t1->min, t2->min);
	compare_proto_thermal_spot(t1->max, t2->max);
	compare_proto_thermal_spot(t1->probe, t2->probe);
}


static void compare_lfic(Vmeta__LFICMetadata *l1, Vmeta__LFICMetadata *l2)
{
	VMETA_ASSERT_BOTH_NULL_NOTNULL(l1, l2);
	if (!l1 || !l2)
		return;

	CU_ASSERT_EQUAL(l1->grid_precision, l2->grid_precision);
	CU_ASSERT_EQUAL(l1->x, l2->x);
	CU_ASSERT_EQUAL(l1->y, l2->y);
	compare_proto_location(l1->location, l2->location);
}


static void compare_timed_metadata(const Vmeta__TimedMetadata *t1,
				   const Vmeta__TimedMetadata *t2)
{
	VMETA_ASSERT_BOTH_NULL_NOTNULL(t1, t2);
	if (!t1 || !t2)
		return;

	compare_drone(t1->drone, t2->drone);
	compare_camera(t1->camera, t2->camera);
	CU_ASSERT_EQUAL(t1->n_links, t2->n_links);
	if (t1->n_links == t2->n_links) {
		for (size_t i = 0; i < t1->n_links; i++)
			compare_link(t1->links[i], t2->links[i]);
	}
	compare_tracking(t1->tracking, t2->tracking);
	compare_proposal(t1->proposal, t2->proposal);
	compare_automation(t1->automation, t2->automation);
	compare_thermal(t1->thermal, t2->thermal);
	compare_lfic(t1->lfic, t2->lfic);
}


static void meta_compare(struct vmeta_frame *f1, struct vmeta_frame *f2)
{
	int err;
	CU_ASSERT_PTR_NOT_NULL(f1);
	CU_ASSERT_PTR_NOT_NULL(f2);
	if (!f1 || !f2)
		return;

	CU_ASSERT_EQUAL(f1->type, VMETA_FRAME_TYPE_PROTO);
	CU_ASSERT_EQUAL(f2->type, VMETA_FRAME_TYPE_PROTO);

	const Vmeta__TimedMetadata *m1, *m2;
	err = vmeta_frame_proto_get_unpacked(f1, &m1);
	CU_ASSERT_EQUAL(err, 0);
	CU_ASSERT_PTR_NOT_NULL(m1);
	err = vmeta_frame_proto_get_unpacked(f2, &m2);
	CU_ASSERT_EQUAL(err, 0);
	CU_ASSERT_PTR_NOT_NULL(m2);
	compare_timed_metadata(m1, m2);
	err = vmeta_frame_proto_release_unpacked(f1, m1);
	CU_ASSERT_EQUAL(err, 0);
	err = vmeta_frame_proto_release_unpacked(f2, m2);
	CU_ASSERT_EQUAL(err, 0);
}


static void test_api(void)
{
	int res;
	struct vmeta_frame *frame = NULL;
	const Vmeta__TimedMetadata *ctm;
	Vmeta__TimedMetadata *tm, *tm2;
	const uint8_t *buf;
	size_t len;

	/* Create a metadata */
	frame = unpacked_meta(0);
	CU_ASSERT_PTR_NOT_NULL(frame);

	/* check others getters in simple mode */
	res = vmeta_frame_proto_get_unpacked(frame, &ctm);
	CU_ASSERT_EQUAL(res, 0);
	CU_ASSERT_PTR_NOT_NULL(ctm);
	res = vmeta_frame_proto_release_unpacked(frame, ctm);
	CU_ASSERT_EQUAL(res, 0);

	res = vmeta_frame_proto_get_unpacked_rw(frame, &tm);
	CU_ASSERT_EQUAL(res, 0);
	CU_ASSERT_PTR_NOT_NULL(tm);
	res = vmeta_frame_proto_release_unpacked_rw(frame, tm);
	CU_ASSERT_EQUAL(res, 0);

	res = vmeta_frame_proto_get_buffer(frame, &buf, &len);
	CU_ASSERT_EQUAL(res, 0);
	CU_ASSERT_PTR_NOT_NULL(buf);
	res = vmeta_frame_proto_release_buffer(frame, buf);
	CU_ASSERT_EQUAL(res, 0);

	/* Multiple read-lock calls */
	res = vmeta_frame_proto_get_unpacked(frame, &ctm);
	CU_ASSERT_EQUAL(res, 0);
	CU_ASSERT_PTR_NOT_NULL(ctm);
	res = vmeta_frame_proto_get_buffer(frame, &buf, &len);
	CU_ASSERT_EQUAL(res, 0);
	CU_ASSERT_PTR_NOT_NULL(buf);
	res = vmeta_frame_proto_get_unpacked_rw(frame, &tm);
	CU_ASSERT_EQUAL(res, -EBUSY);
	res = vmeta_frame_proto_release_unpacked(frame, ctm);
	CU_ASSERT_EQUAL(res, 0);
	res = vmeta_frame_proto_release_buffer(frame, buf);
	CU_ASSERT_EQUAL(res, 0);

	/* write-lock */
	res = vmeta_frame_proto_get_unpacked_rw(frame, &tm);
	CU_ASSERT_EQUAL(res, 0);
	CU_ASSERT_PTR_NOT_NULL(tm);
	res = vmeta_frame_proto_get_unpacked(frame, &ctm);
	CU_ASSERT_EQUAL(res, -EBUSY);
	res = vmeta_frame_proto_get_buffer(frame, &buf, &len);
	CU_ASSERT_EQUAL(res, -EBUSY);
	res = vmeta_frame_proto_get_unpacked_rw(frame, &tm2);
	CU_ASSERT_EQUAL(res, -EBUSY);
	res = vmeta_frame_proto_release_unpacked_rw(frame, tm);
	CU_ASSERT_EQUAL(res, 0);

	res = vmeta_frame_unref(frame);
	CU_ASSERT_EQUAL(res, 0);
}


static void test_write(void)
{
	struct vmeta_frame *frame = NULL;
	const size_t buflen = 1024;
	uint8_t *buf = NULL;
	struct vmeta_buffer vb;
	int res;

	frame = unpacked_meta(0);
	CU_ASSERT_PTR_NOT_NULL(frame);

	buf = malloc(buflen);
	CU_ASSERT_PTR_NOT_NULL(buf);
	vmeta_buffer_set_data(&vb, buf, buflen, 0);

	res = vmeta_frame_write(&vb, frame);
	CU_ASSERT_EQUAL(res, 0);
	CU_ASSERT_EQUAL(vb.pos, sizeof(packed_meta));
	CU_ASSERT_EQUAL(memcmp(buf, packed_meta, sizeof(packed_meta)), 0);

	free(buf);
	vmeta_frame_unref(frame);
}


static void test_read(void)
{
	struct vmeta_frame *frame, *ref;
	struct vmeta_buffer vb;
	int err;

	vmeta_buffer_set_cdata(&vb, packed_meta, sizeof(packed_meta), 0);

	ref = unpacked_meta(0);
	CU_ASSERT_PTR_NOT_NULL(ref);
	err = vmeta_frame_read(&vb, VMETA_FRAME_PROTO_MIME_TYPE, &frame);
	CU_ASSERT_PTR_NOT_NULL(frame);
	CU_ASSERT_EQUAL(err, 0);

	meta_compare(ref, frame);
	compare_vmeta_frame_getters(ref, frame);
	compare_vmeta_frame_proto_getters(frame);

	vmeta_frame_unref(frame);
	vmeta_frame_unref(ref);
}


static void test_write_read_once(void)
{
	struct vmeta_frame *in, *out;
	uint8_t *buf;
	const size_t buflen = 1 * 1024 * 1024; /* 1M should be enough */
	struct vmeta_buffer vb;
	int res, err;

	buf = malloc(buflen);
	CU_ASSERT_PTR_NOT_NULL(buf);
	vmeta_buffer_set_data(&vb, buf, buflen, 0);

	in = unpacked_meta(1);
	CU_ASSERT_PTR_NOT_NULL(in);

	res = vmeta_frame_write(&vb, in);
	CU_ASSERT_EQUAL(res, 0);

	vb.len = vb.pos;
	vb.pos = 0;
	err = vmeta_frame_read(&vb, VMETA_FRAME_PROTO_MIME_TYPE, &out);
	CU_ASSERT_PTR_NOT_NULL(out);
	CU_ASSERT_EQUAL(err, 0);

	meta_compare(in, out);
	compare_vmeta_frame_getters(in, out);
	compare_vmeta_frame_proto_getters(out);

	free(buf);
	vmeta_frame_unref(in);
	vmeta_frame_unref(out);
}


static void test_write_read(void)
{
	/* Since write_read test is random, do it multiple times */
	for (int i = 0; i < MONKEY_TEST_COUNT; i++)
		test_write_read_once();
}


static void test_read_write(void)
{
	struct vmeta_frame *tmp;
	uint8_t *buf;
	const size_t buflen = 1024;
	struct vmeta_buffer in, out;
	int err;

	buf = malloc(buflen);
	CU_ASSERT_PTR_NOT_NULL(buf);
	vmeta_buffer_set_data(&out, buf, buflen, 0);
	vmeta_buffer_set_cdata(&in, packed_meta, sizeof(packed_meta), 0);

	err = vmeta_frame_read(&in, VMETA_FRAME_PROTO_MIME_TYPE, &tmp);
	CU_ASSERT_PTR_NOT_NULL(tmp);
	CU_ASSERT_EQUAL(err, 0);

	err = vmeta_frame_write(&out, tmp);
	CU_ASSERT_EQUAL(err, 0);

	CU_ASSERT_EQUAL(in.len, out.pos);
	CU_ASSERT_EQUAL(memcmp(in.data, out.data, in.len), 0);

	free(buf);
	vmeta_frame_unref(tmp);
}


static void gen_packed_meta(void)
{
	int res = 0;
	const uint8_t *buf;
	size_t len;

	struct vmeta_frame *ref = unpacked_meta(0);
	CU_ASSERT_PTR_NOT_NULL_FATAL(ref);
	res = vmeta_frame_proto_get_buffer(ref, &buf, &len);
	CU_ASSERT_EQUAL_FATAL(res, 0);

	fprintf(stderr, "\n\n/* **** PROTO **** */\n");
	fprintf(stderr, "static const uint8_t packed_meta[] = {\n\t");
	for (size_t i = 0; i < len; i++) {
		fprintf(stderr, "0x%02x,", buf[i]);
		if ((i % 12) == 11 && i < (len - 1))
			fprintf(stderr, "\n\t");
		else if (i < (len - 1))
			fprintf(stderr, " ");
	}
	fprintf(stderr, "\n};\n\n");

	vmeta_frame_proto_release_buffer(ref, buf);
	vmeta_frame_unref(ref);
}


CU_TestInfo s_proto_tests[] = {
	{(char *)"vmeta api", &test_api},
	{(char *)"vmeta write", &test_write},
	{(char *)"vmeta read", &test_read},
	{(char *)"vmeta read->write", &test_read_write},
	CU_TEST_INFO_NULL,
};

CU_TestInfo s_proto_monkey[] = {
	{(char *)"vmeta write->read monkey tests", &test_write_read},
	CU_TEST_INFO_NULL,
};

CU_TestInfo s_proto_gen[] = {
	{(char *)"vmeta packed_meta generation", &gen_packed_meta},
	CU_TEST_INFO_NULL,
};
